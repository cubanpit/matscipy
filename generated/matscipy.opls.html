

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>matscipy.opls &mdash; matscipy devel documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=1dba82e2"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="matscipy.angle_distribution" href="matscipy.angle_distribution.html" />
    <link rel="prev" title="matscipy.hydrogenate" href="matscipy.hydrogenate.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            matscipy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">matscipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/index.html">Application domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Analysis tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../calculators/index.html">Interatomic potentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topology/index.html">Structure and topology generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cli/index.html">Command line interface</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api.html#application-domains">Application domains</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html#structure-and-topology-generation">Structure and topology generation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="matscipy.hydrogenate.html">matscipy.hydrogenate</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">matscipy.opls</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.twochar"><code class="docutils literal notranslate"><span class="pre">twochar()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.LJQData"><code class="docutils literal notranslate"><span class="pre">LJQData</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.BondData"><code class="docutils literal notranslate"><span class="pre">BondData</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.CutoffList"><code class="docutils literal notranslate"><span class="pre">CutoffList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.AnglesData"><code class="docutils literal notranslate"><span class="pre">AnglesData</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.DihedralsData"><code class="docutils literal notranslate"><span class="pre">DihedralsData</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#matscipy.opls.OPLSStructure"><code class="docutils literal notranslate"><span class="pre">OPLSStructure</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#analysis-tools">Analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#interatomic-potentials">Interatomic potentials</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html#utility-functions">Utility functions</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="matscipy.html">matscipy</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="matscipy.html#matscipy.has_parameter"><code class="docutils literal notranslate"><span class="pre">has_parameter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.html#matscipy.parameter"><code class="docutils literal notranslate"><span class="pre">parameter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.angle_distribution.html">matscipy.angle_distribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.atomic_strain.html">matscipy.atomic_strain</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.calculators.html">matscipy.calculators</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.cauchy_born.html">matscipy.cauchy_born</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.cli.html">matscipy.cli</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.compat.html">matscipy.compat</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.deformation.html">matscipy.deformation</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.dislocation.html">matscipy.dislocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.drift.html">matscipy.drift</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.elasticity.html">matscipy.elasticity</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.electrochemistry.html">matscipy.electrochemistry</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.ffi.html">matscipy.ffi</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.fracture_mechanics.html">matscipy.fracture_mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.gamma_surface.html">matscipy.gamma_surface</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.hydrogenate.html">matscipy.hydrogenate</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.io.html">matscipy.io</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.logger.html">matscipy.logger</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.molecules.html">matscipy.molecules</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.neighbours.html">matscipy.neighbours</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.numerical.html">matscipy.numerical</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.numpy_tricks.html">matscipy.numpy_tricks</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">matscipy.opls</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.optimize.html">matscipy.optimize</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.precon.html">matscipy.precon</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.pressurecoupling.html">matscipy.pressurecoupling</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.rings.html">matscipy.rings</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.socketcalc.html">matscipy.socketcalc</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.spatial_correlation_function.html">matscipy.spatial_correlation_function</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.surface.html">matscipy.surface</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.surface_reconstruction.html">matscipy.surface_reconstruction</a></li>
<li class="toctree-l4"><a class="reference internal" href="matscipy.utils.html">matscipy.utils</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="matscipy.io.html">matscipy.io</a></li>
<li class="toctree-l3"><a class="reference internal" href="matscipy.numpy_tricks.html">matscipy.numpy_tricks</a></li>
<li class="toctree-l3"><a class="reference internal" href="matscipy.logger.html">matscipy.logger</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">matscipy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api.html">API Reference</a></li>
      <li class="breadcrumb-item active">matscipy.opls</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/generated/matscipy.opls.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-matscipy.opls">
<span id="matscipy-opls"></span><h1>matscipy.opls<a class="headerlink" href="#module-matscipy.opls" title="Link to this heading"></a></h1>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.twochar" title="matscipy.opls.twochar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">twochar</span></code></a>(name)</p></td>
<td><p>Ensures that the particle names have a length of exactly two characters.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.AnglesData" title="matscipy.opls.AnglesData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AnglesData</span></code></a>([name_value_hash])</p></td>
<td><p>Store spring constants and equilibrium angles for harmonic potentials and ensure correct handling of permutations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.BondData" title="matscipy.opls.BondData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BondData</span></code></a>([name_value_hash])</p></td>
<td><p>Store spring constants and equilibrium distances for harmonic potentials and ensure correct handling of permutations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.CutoffList" title="matscipy.opls.CutoffList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CutoffList</span></code></a>([name_value_hash])</p></td>
<td><p>Store cutoffs for pair interactions and ensure correct handling of permutations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.DihedralsData" title="matscipy.opls.DihedralsData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DihedralsData</span></code></a>([name_value_hash])</p></td>
<td><p>Store energy constants for dihedral potentials and ensure correct handling of permutations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData" title="matscipy.opls.LJQData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LJQData</span></code></a>(args)</p></td>
<td><p>Store Lennard-Jones parameters and charges for each particle type.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure" title="matscipy.opls.OPLSStructure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OPLSStructure</span></code></a>(*args, **kwargs)</p></td>
<td><p>Extension of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.Atoms</span></code> class for non-reactive simulations.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.opls.twochar">
<span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">twochar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.twochar" title="Link to this definition"></a></dt>
<dd><p>Ensures that the particle names have a length of exactly two
characters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Particle name.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Particle name with exactly 2 characters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.LJQData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">LJQData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>Store Lennard-Jones parameters and charges for each particle type. In
the simplest version, each particle type has one set of Lennard-Jones
parameters, with geometric mixing applied between parameters of
different types. Parameters for individual pairs of particle types can
be specified in the <code class="docutils literal notranslate"><span class="pre">lj_pairs</span></code> dictionary.</p>
<p>Example:
Set the Lennard-Jones and Coulomb cutoffs to 12 and 8 Angstroms, geometric
mixing of the Lennard-Jones parameters for particles <code class="docutils literal notranslate"><span class="pre">C1</span></code> and <code class="docutils literal notranslate"><span class="pre">C2</span></code> and
between <code class="docutils literal notranslate"><span class="pre">C2</span></code> and <code class="docutils literal notranslate"><span class="pre">C3</span></code>, custom parameters and cutoff for the interaction
between <code class="docutils literal notranslate"><span class="pre">C1</span></code> and <code class="docutils literal notranslate"><span class="pre">C3</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LJQData</span><span class="o">.</span><span class="n">lj_cutoff</span> <span class="o">=</span> <span class="mf">12.0</span>
<span class="n">LJQData</span><span class="o">.</span><span class="n">c_cutoff</span>  <span class="o">=</span>  <span class="mf">8.0</span>

<span class="n">LJQData</span><span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">LJ</span><span class="o">-</span><span class="n">epsilon</span> <span class="p">(</span><span class="n">eV</span><span class="p">),</span> <span class="n">LJ</span><span class="o">-</span><span class="n">sigma</span> <span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">charge</span> <span class="p">(</span><span class="n">e</span><span class="p">)]</span>
<span class="n">LJQData</span><span class="p">[</span><span class="s1">&#39;C2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">LJ</span><span class="o">-</span><span class="n">epsilon</span> <span class="p">(</span><span class="n">eV</span><span class="p">),</span> <span class="n">LJ</span><span class="o">-</span><span class="n">sigma</span> <span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">charge</span> <span class="p">(</span><span class="n">e</span><span class="p">)]</span>
<span class="n">LJQData</span><span class="p">[</span><span class="s1">&#39;C3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">LJ</span><span class="o">-</span><span class="n">epsilon</span> <span class="p">(</span><span class="n">eV</span><span class="p">),</span> <span class="n">LJ</span><span class="o">-</span><span class="n">sigma</span> <span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">charge</span> <span class="p">(</span><span class="n">e</span><span class="p">)]</span>

<span class="n">LJQData</span><span class="o">.</span><span class="n">lj_pairs</span><span class="p">[</span><span class="s1">&#39;C1-C3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">epsilon</span> <span class="p">(</span><span class="n">eV</span><span class="p">),</span> <span class="n">sigma</span> <span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">cutoff</span> <span class="p">(</span><span class="n">A</span><span class="p">)]</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.clear" title="matscipy.opls.LJQData.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.copy" title="matscipy.opls.LJQData.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.fromkeys" title="matscipy.opls.LJQData.fromkeys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code></a>(iterable[, value])</p></td>
<td><p>Create a new dictionary with keys from iterable and values set to value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.get" title="matscipy.opls.LJQData.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(key[, default])</p></td>
<td><p>Return the value for key if key is in the dictionary, else default.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.items" title="matscipy.opls.LJQData.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.keys" title="matscipy.opls.LJQData.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.pop" title="matscipy.opls.LJQData.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>(key[, default])</p></td>
<td><p>If the key is not found, return the default if given; otherwise, raise a KeyError.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.popitem" title="matscipy.opls.LJQData.popitem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code></a>(/)</p></td>
<td><p>Remove and return a (key, value) pair as a 2-tuple.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.setdefault" title="matscipy.opls.LJQData.setdefault"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code></a>(key[, default])</p></td>
<td><p>Insert key with a value of default if key is not in the dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.update" title="matscipy.opls.LJQData.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>([E, ]**F)</p></td>
<td><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.LJQData.values" title="matscipy.opls.LJQData.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.__init__" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None.</span>&#160; <span class="pre">Remove</span> <span class="pre">all</span> <span class="pre">items</span> <span class="pre">from</span> <span class="pre">D.</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.clear" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">shallow</span> <span class="pre">copy</span> <span class="pre">of</span> <span class="pre">D</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.copy" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.fromkeys">
<span class="sig-name descname"><span class="pre">fromkeys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.fromkeys" title="Link to this definition"></a></dt>
<dd><p>Create a new dictionary with keys from iterable and values set to value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.get" title="Link to this definition"></a></dt>
<dd><p>Return the value for key if key is in the dictionary, else default.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">items</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.items" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">a</span> <span class="pre">set-like</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">keys</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.keys" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=&lt;unrepresentable&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.pop" title="Link to this definition"></a></dt>
<dd><p>If the key is not found, return the default if given; otherwise,
raise a KeyError.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.popitem">
<span class="sig-name descname"><span class="pre">popitem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.popitem" title="Link to this definition"></a></dt>
<dd><p>Remove and return a (key, value) pair as a 2-tuple.</p>
<p>Pairs are returned in LIFO (last-in, first-out) order.
Raises KeyError if the dict is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.setdefault">
<span class="sig-name descname"><span class="pre">setdefault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.LJQData.setdefault" title="Link to this definition"></a></dt>
<dd><p>Insert key with a value of default if key is not in the dictionary.</p>
<p>Return the value for key if key is in the dictionary, else default.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">**F</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None.</span>&#160; <span class="pre">Update</span> <span class="pre">D</span> <span class="pre">from</span> <span class="pre">dict/iterable</span> <span class="pre">E</span> <span class="pre">and</span> <span class="pre">F.</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.update" title="Link to this definition"></a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.LJQData.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">an</span> <span class="pre">object</span> <span class="pre">providing</span> <span class="pre">a</span> <span class="pre">view</span> <span class="pre">on</span> <span class="pre">D's</span> <span class="pre">values</span></span></span><a class="headerlink" href="#matscipy.opls.LJQData.values" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.BondData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">BondData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store spring constants and equilibrium distances for harmonic potentials
and ensure correct handling of permutations. See documentation of the
LAMMPS <code class="docutils literal notranslate"><span class="pre">bond_style</span> <span class="pre">harmonic</span></code> command for details.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.BondData.get_name" title="matscipy.opls.BondData.get_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_name</span></code></a>(aname, bname)</p></td>
<td><p>Returns the name of the bond type between two particle types as it is defined internally.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.BondData.get_value" title="matscipy.opls.BondData.get_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_value</span></code></a>(aname, bname)</p></td>
<td><p>Returns the potential parameters for a bond between two particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code>, i.e. the spring constant and the equilibrium distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.BondData.name_value" title="matscipy.opls.BondData.name_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name_value</span></code></a>(aname, bname)</p></td>
<td><p>Returns the name of a bond type between two particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code> as stored internally and the corresponding potential parameters, i.e. the spring constant and the equilibrium distance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.BondData.set_names" title="matscipy.opls.BondData.set_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_names</span></code></a>(names)</p></td>
<td><p>Create a list of participating particles from a list of bond types.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.BondData.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData.__init__" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name_value_hash</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Bond names and corresponding potential parameters, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;AA-BB&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="s1">&#39;AA-CC&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="o">...</span><span class="p">}</span><span class="o">.</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.BondData.set_names">
<span class="sig-name descname"><span class="pre">set_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData.set_names" title="Link to this definition"></a></dt>
<dd><p>Create a list of participating particles from a list of bond
types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list</em>) – <p>List of bond type names, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;AA-BB&#39;</span><span class="p">,</span> <span class="s1">&#39;AA-CC&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.BondData.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData.get_name" title="Link to this definition"></a></dt>
<dd><p>Returns the name of the bond type between two particle types
as it is defined internally. If one particle is named <code class="docutils literal notranslate"><span class="pre">AA</span></code>
and the other is named <code class="docutils literal notranslate"><span class="pre">BB</span></code>, the bond type between them could
be either <code class="docutils literal notranslate"><span class="pre">AA-BB</span></code> or <code class="docutils literal notranslate"><span class="pre">BB-AA</span></code>. The parameters would be the same
and are stored only once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Bond-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname</span></code> or <code class="docutils literal notranslate"><span class="pre">bname-aname</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.BondData.name_value">
<span class="sig-name descname"><span class="pre">name_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData.name_value" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a bond type between two particles of type
<code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code> as stored internally and the corresponding
potential parameters, i.e. the spring constant and the equilibrium
distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Bond-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname</span></code> or <code class="docutils literal notranslate"><span class="pre">bname-aname</span></code>.</p></li>
<li><p><strong>parameters</strong> (<em>list</em>) – Potential parameters, i.e. spring constant and
equilibrium distance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.BondData.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.BondData.get_value" title="Link to this definition"></a></dt>
<dd><p>Returns the potential parameters for a bond between two
particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code>, i.e. the spring
constant and the equilibrium distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Potential parameters, i.e. spring constant and
equilibrium distance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">CutoffList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.opls.BondData" title="matscipy.opls.BondData"><code class="xref py py-class docutils literal notranslate"><span class="pre">BondData</span></code></a></p>
<p>Store cutoffs for pair interactions and ensure correct handling of
permutations. Cutoffs can be used to automatically find all interacting
atoms of a <a class="reference internal" href="#matscipy.opls.OPLSStructure" title="matscipy.opls.OPLSStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">matscipy.opls.OPLSStructure</span></code></a> object based on a simple
distance criterion.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.CutoffList.get_name" title="matscipy.opls.CutoffList.get_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_name</span></code></a>(aname, bname)</p></td>
<td><p>Returns the name of the bond type between two particle types as it is defined internally.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.CutoffList.get_value" title="matscipy.opls.CutoffList.get_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_value</span></code></a>(aname, bname)</p></td>
<td><p>Returns the potential parameters for a bond between two particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code>, i.e. the spring constant and the equilibrium distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.CutoffList.name_value" title="matscipy.opls.CutoffList.name_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name_value</span></code></a>(aname, bname)</p></td>
<td><p>Returns the name of a bond type between two particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code> as stored internally and the corresponding potential parameters, i.e. the spring constant and the equilibrium distance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.CutoffList.set_names" title="matscipy.opls.CutoffList.set_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_names</span></code></a>(names)</p></td>
<td><p>Create a list of participating particles from a list of bond types.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>max</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.max" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.__init__" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name_value_hash</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Bond names and corresponding potential parameters, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;AA-BB&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="s1">&#39;AA-CC&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="o">...</span><span class="p">}</span><span class="o">.</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.get_name" title="Link to this definition"></a></dt>
<dd><p>Returns the name of the bond type between two particle types
as it is defined internally. If one particle is named <code class="docutils literal notranslate"><span class="pre">AA</span></code>
and the other is named <code class="docutils literal notranslate"><span class="pre">BB</span></code>, the bond type between them could
be either <code class="docutils literal notranslate"><span class="pre">AA-BB</span></code> or <code class="docutils literal notranslate"><span class="pre">BB-AA</span></code>. The parameters would be the same
and are stored only once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Bond-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname</span></code> or <code class="docutils literal notranslate"><span class="pre">bname-aname</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.get_value" title="Link to this definition"></a></dt>
<dd><p>Returns the potential parameters for a bond between two
particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code>, i.e. the spring
constant and the equilibrium distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Potential parameters, i.e. spring constant and
equilibrium distance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.name_value">
<span class="sig-name descname"><span class="pre">name_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.name_value" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a bond type between two particles of type
<code class="docutils literal notranslate"><span class="pre">aname</span></code> and <code class="docutils literal notranslate"><span class="pre">bname</span></code> as stored internally and the corresponding
potential parameters, i.e. the spring constant and the equilibrium
distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Bond-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname</span></code> or <code class="docutils literal notranslate"><span class="pre">bname-aname</span></code>.</p></li>
<li><p><strong>parameters</strong> (<em>list</em>) – Potential parameters, i.e. spring constant and
equilibrium distance.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.CutoffList.set_names">
<span class="sig-name descname"><span class="pre">set_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.CutoffList.set_names" title="Link to this definition"></a></dt>
<dd><p>Create a list of participating particles from a list of bond
types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list</em>) – <p>List of bond type names, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;AA-BB&#39;</span><span class="p">,</span> <span class="s1">&#39;AA-CC&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">AnglesData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store spring constants and equilibrium angles for harmonic potentials
and ensure correct handling of permutations. See documentation of the
LAMMPS <code class="docutils literal notranslate"><span class="pre">angle_style</span> <span class="pre">harmonic</span></code> command for details.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.AnglesData.add_name" title="matscipy.opls.AnglesData.add_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_name</span></code></a>(aname, bname, cname)</p></td>
<td><p>Add an angle type to the internal list if not already present.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.AnglesData.get_name" title="matscipy.opls.AnglesData.get_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_name</span></code></a>(aname, bname, cname)</p></td>
<td><p>Returns the name of the angle type between three particle types as it is defined internally.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.AnglesData.name_value" title="matscipy.opls.AnglesData.name_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name_value</span></code></a>(aname, bname, cname)</p></td>
<td><p>Returns the name of an angle type between three particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code>, <code class="docutils literal notranslate"><span class="pre">bname</span></code> and <code class="docutils literal notranslate"><span class="pre">cname</span></code> as stored internally and the corresponding potential parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.AnglesData.set_names" title="matscipy.opls.AnglesData.set_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_names</span></code></a>(names)</p></td>
<td><p>Create a list of participating particles from a list of angle types.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData.__init__" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name_value_hash</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Angle names and corresponding potential parameters, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;AA-BB-CC&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="s1">&#39;AA-CC-BB&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData.set_names">
<span class="sig-name descname"><span class="pre">set_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData.set_names" title="Link to this definition"></a></dt>
<dd><p>Create a list of participating particles from a list of angle
types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list</em>) – <p>List of angle type names, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;AA-BB-CC&#39;</span><span class="p">,</span> <span class="s1">&#39;AA-CC-BB&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData.add_name">
<span class="sig-name descname"><span class="pre">add_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData.add_name" title="Link to this definition"></a></dt>
<dd><p>Add an angle type to the internal list if not already present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData.get_name" title="Link to this definition"></a></dt>
<dd><p>Returns the name of the angle type between three particle
types as it is defined internally. If the particles are named
<code class="docutils literal notranslate"><span class="pre">AA</span></code>, <code class="docutils literal notranslate"><span class="pre">BB</span></code>, <code class="docutils literal notranslate"><span class="pre">CC</span></code>, the angle type could be <code class="docutils literal notranslate"><span class="pre">AA-BB-CC</span></code>
or <code class="docutils literal notranslate"><span class="pre">CC-BB-AA</span></code>. The parameters would be the same and are
stored only once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Angle-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname-cname</span></code>
or <code class="docutils literal notranslate"><span class="pre">cname-bname-aname</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.AnglesData.name_value">
<span class="sig-name descname"><span class="pre">name_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.AnglesData.name_value" title="Link to this definition"></a></dt>
<dd><p>Returns the name of an angle type between three particles of
type <code class="docutils literal notranslate"><span class="pre">aname</span></code>, <code class="docutils literal notranslate"><span class="pre">bname</span></code> and <code class="docutils literal notranslate"><span class="pre">cname</span></code> as stored internally
and the corresponding potential parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Angle-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname-cname</span></code>
or <code class="docutils literal notranslate"><span class="pre">cname-bname-aname</span></code>.</p></li>
<li><p><strong>parameters</strong> (<em>list</em>) – Potential parameters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">DihedralsData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Store energy constants for dihedral potentials and ensure correct handling
of permutations. See documentation of the LAMMPS <code class="docutils literal notranslate"><span class="pre">dihedral_style</span> <span class="pre">opls</span></code>
command for details.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.DihedralsData.add_name" title="matscipy.opls.DihedralsData.add_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_name</span></code></a>(aname, bname, cname, dname)</p></td>
<td><p>Add a dihedral type to the internal list if not already present.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.DihedralsData.get_name" title="matscipy.opls.DihedralsData.get_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_name</span></code></a>(aname, bname, cname, dname)</p></td>
<td><p>Add a dihedral type to the internal list if not already present.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.DihedralsData.name_value" title="matscipy.opls.DihedralsData.name_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name_value</span></code></a>(aname, bname, cname, dname)</p></td>
<td><p>Returns the name of a dihedral type between four particles of type <code class="docutils literal notranslate"><span class="pre">aname</span></code>, <code class="docutils literal notranslate"><span class="pre">bname</span></code>, <code class="docutils literal notranslate"><span class="pre">cname</span></code> and <code class="docutils literal notranslate"><span class="pre">dname</span></code> as stored internally and the corresponding potential parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.DihedralsData.set_names" title="matscipy.opls.DihedralsData.set_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_names</span></code></a>(names)</p></td>
<td><p>Create a list of participating particles from a list of dihedral types.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name_value_hash</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData.__init__" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name_value_hash</strong> (<em>dict</em><em>, </em><em>optional</em>) – <p>Dihedral names and corresponding potential parameters, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;AA-BB-CC-DD&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
 <span class="s1">&#39;AA-BB-AA-BB&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData.set_names">
<span class="sig-name descname"><span class="pre">set_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData.set_names" title="Link to this definition"></a></dt>
<dd><p>Create a list of participating particles from a list of
dihedral types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>names</strong> (<em>list</em>) – <p>List of dihedral type names, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;AA-BB-CC-DD&#39;</span><span class="p">,</span> <span class="s1">&#39;AA-BB-AA-BB&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData.add_name">
<span class="sig-name descname"><span class="pre">add_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData.add_name" title="Link to this definition"></a></dt>
<dd><p>Add a dihedral type to the internal list if not already
present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
<li><p><strong>dname</strong> (<em>str</em>) – Name of fourth particle.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData.get_name" title="Link to this definition"></a></dt>
<dd><p>Add a dihedral type to the internal list if not already
present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
<li><p><strong>dname</strong> (<em>str</em>) – Name of fourth particle.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.DihedralsData.name_value">
<span class="sig-name descname"><span class="pre">name_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.DihedralsData.name_value" title="Link to this definition"></a></dt>
<dd><p>Returns the name of a dihedral type between four particles of
type <code class="docutils literal notranslate"><span class="pre">aname</span></code>, <code class="docutils literal notranslate"><span class="pre">bname</span></code>, <code class="docutils literal notranslate"><span class="pre">cname</span></code> and <code class="docutils literal notranslate"><span class="pre">dname</span></code> as stored
internally and the corresponding potential parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aname</strong> (<em>str</em>) – Name of first particle.</p></li>
<li><p><strong>bname</strong> (<em>str</em>) – Name of second particle.</p></li>
<li><p><strong>cname</strong> (<em>str</em>) – Name of third particle.</p></li>
<li><p><strong>dname</strong> (<em>str</em>) – Name of fourth particle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Angle-name, either <code class="docutils literal notranslate"><span class="pre">aname-bname-cname-dname</span></code>
or <code class="docutils literal notranslate"><span class="pre">dname-cname-bname-aname</span></code>.</p></li>
<li><p><strong>parameters</strong> (<em>list</em>) – Potential parameters.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.opls.</span></span><span class="sig-name descname"><span class="pre">OPLSStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Atoms</span></code></p>
<p>Extension of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.Atoms</span></code> class for non-reactive simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.calc" title="matscipy.opls.OPLSStructure.calc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc</span></code></a></dt><dd><p>Calculator object.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.cell" title="matscipy.opls.OPLSStructure.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.cell.Cell</span></code> for direct manipulation.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.constraints" title="matscipy.opls.OPLSStructure.constraints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">constraints</span></code></a></dt><dd><p>Constraints of the atoms.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.number_of_lattice_vectors" title="matscipy.opls.OPLSStructure.number_of_lattice_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_lattice_vectors</span></code></a></dt><dd><p>Number of (non-zero) lattice vectors.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.numbers" title="matscipy.opls.OPLSStructure.numbers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numbers</span></code></a></dt><dd><p>Attribute for direct manipulation of the atomic numbers.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.pbc" title="matscipy.opls.OPLSStructure.pbc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pbc</span></code></a></dt><dd><p>Reference to pbc-flags for in-place manipulations.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.positions" title="matscipy.opls.OPLSStructure.positions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">positions</span></code></a></dt><dd><p>Attribute for direct manipulation of the positions.</p>
</dd>
<dt><a class="reference internal" href="#matscipy.opls.OPLSStructure.symbols" title="matscipy.opls.OPLSStructure.symbols"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symbols</span></code></a></dt><dd><p>Get chemical symbols as a <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.symbols.Symbols</span></code> object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.append" title="matscipy.opls.OPLSStructure.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(atom)</p></td>
<td><p>Append atom to the end.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.center" title="matscipy.opls.OPLSStructure.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a>([vacuum, axis, about])</p></td>
<td><p>Center atoms in unit cell.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.copy" title="matscipy.opls.OPLSStructure.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return a copy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.edit" title="matscipy.opls.OPLSStructure.edit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edit</span></code></a>()</p></td>
<td><p>Modify atoms interactively through ASE's GUI viewer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.euler_rotate" title="matscipy.opls.OPLSStructure.euler_rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_rotate</span></code></a>([phi, theta, psi, center])</p></td>
<td><p>Rotate atoms via Euler angles (in degrees).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.extend" title="matscipy.opls.OPLSStructure.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(other)</p></td>
<td><p>Extend atoms object by appending atoms from <em>other</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.fromdict" title="matscipy.opls.OPLSStructure.fromdict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromdict</span></code></a>(dct)</p></td>
<td><p>Rebuild atoms object from dictionary representation (todict).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_all_distances" title="matscipy.opls.OPLSStructure.get_all_distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_all_distances</span></code></a>([mic, vector])</p></td>
<td><p>Return distances of all of the atoms with all of the atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_angle" title="matscipy.opls.OPLSStructure.get_angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_angle</span></code></a>(a1, a2, a3[, mic])</p></td>
<td><p>Get angle formed by three atoms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_angles" title="matscipy.opls.OPLSStructure.get_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_angles</span></code></a>([angles])</p></td>
<td><p>Returns an array of all angle types and an array of all angles in the system.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_angular_momentum" title="matscipy.opls.OPLSStructure.get_angular_momentum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_angular_momentum</span></code></a>()</p></td>
<td><p>Get total angular momentum with respect to the center of mass.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_array" title="matscipy.opls.OPLSStructure.get_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_array</span></code></a>(name[, copy])</p></td>
<td><p>Get an array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_atomic_numbers" title="matscipy.opls.OPLSStructure.get_atomic_numbers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_atomic_numbers</span></code></a>()</p></td>
<td><p>Get integer array of atomic numbers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_bonds" title="matscipy.opls.OPLSStructure.get_bonds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_bonds</span></code></a>([bonds])</p></td>
<td><p>Returns an array of all bond types and an array of all bonds in the system.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_calculator" title="matscipy.opls.OPLSStructure.get_calculator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_calculator</span></code></a>()</p></td>
<td><p>Get currently attached calculator object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_cell" title="matscipy.opls.OPLSStructure.get_cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cell</span></code></a>([complete])</p></td>
<td><p>Get the three unit cell vectors as a <cite>class</cite>:ase.cell.Cell` object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_cell_lengths_and_angles" title="matscipy.opls.OPLSStructure.get_cell_lengths_and_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cell_lengths_and_angles</span></code></a>()</p></td>
<td><p>Get unit cell parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_celldisp" title="matscipy.opls.OPLSStructure.get_celldisp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_celldisp</span></code></a>()</p></td>
<td><p>Get the unit cell displacement vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_center_of_mass" title="matscipy.opls.OPLSStructure.get_center_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_center_of_mass</span></code></a>([scaled, indices])</p></td>
<td><p>Get the center of mass.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_charges" title="matscipy.opls.OPLSStructure.get_charges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_charges</span></code></a>()</p></td>
<td><p>Return an array of atomic charges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_chemical_formula" title="matscipy.opls.OPLSStructure.get_chemical_formula"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_chemical_formula</span></code></a>([mode, empirical])</p></td>
<td><p>Get the chemical formula as a string based on the chemical symbols.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_chemical_symbols" title="matscipy.opls.OPLSStructure.get_chemical_symbols"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_chemical_symbols</span></code></a>()</p></td>
<td><p>Get list of chemical symbol strings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_dihedral" title="matscipy.opls.OPLSStructure.get_dihedral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dihedral</span></code></a>(a0, a1, a2, a3[, mic])</p></td>
<td><p>Calculate dihedral angle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_dihedrals" title="matscipy.opls.OPLSStructure.get_dihedrals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dihedrals</span></code></a>([dihedrals, full_output])</p></td>
<td><p>Returns an array of all dihedral types and an array of all dihedrals in the system.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_dipole_moment" title="matscipy.opls.OPLSStructure.get_dipole_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dipole_moment</span></code></a>()</p></td>
<td><p>Calculate the electric dipole moment for the atoms object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_distance" title="matscipy.opls.OPLSStructure.get_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_distance</span></code></a>(a0, a1[, mic, vector])</p></td>
<td><p>Return distance between two atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_distances" title="matscipy.opls.OPLSStructure.get_distances"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_distances</span></code></a>(a, indices[, mic, vector])</p></td>
<td><p>Return distances of atom No.i with a list of atoms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_forces" title="matscipy.opls.OPLSStructure.get_forces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_forces</span></code></a>([apply_constraint, md])</p></td>
<td><p>Calculate atomic forces.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_global_number_of_atoms" title="matscipy.opls.OPLSStructure.get_global_number_of_atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_global_number_of_atoms</span></code></a>()</p></td>
<td><p>Returns the global number of atoms in a distributed-atoms parallel simulation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_initial_charges" title="matscipy.opls.OPLSStructure.get_initial_charges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_initial_charges</span></code></a>()</p></td>
<td><p>Get array of initial charges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_initial_magnetic_moments" title="matscipy.opls.OPLSStructure.get_initial_magnetic_moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_initial_magnetic_moments</span></code></a>()</p></td>
<td><p>Get array of initial magnetic moments.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_kinetic_energy" title="matscipy.opls.OPLSStructure.get_kinetic_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_kinetic_energy</span></code></a>()</p></td>
<td><p>Get the kinetic energy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_magnetic_moment" title="matscipy.opls.OPLSStructure.get_magnetic_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_magnetic_moment</span></code></a>()</p></td>
<td><p>Get calculated total magnetic moment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_magnetic_moments" title="matscipy.opls.OPLSStructure.get_magnetic_moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_magnetic_moments</span></code></a>()</p></td>
<td><p>Get calculated local magnetic moments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_masses" title="matscipy.opls.OPLSStructure.get_masses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_masses</span></code></a>()</p></td>
<td><p>Get array of masses in atomic mass units.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_momenta" title="matscipy.opls.OPLSStructure.get_momenta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_momenta</span></code></a>()</p></td>
<td><p>Get array of momenta.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_moments_of_inertia" title="matscipy.opls.OPLSStructure.get_moments_of_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_moments_of_inertia</span></code></a>([vectors])</p></td>
<td><p>Get the moments of inertia along the principal axes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_neighbors" title="matscipy.opls.OPLSStructure.get_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_neighbors</span></code></a>()</p></td>
<td><p>Find all atoms which might interact with each other based on a simple distance criterion.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_number_of_atoms" title="matscipy.opls.OPLSStructure.get_number_of_atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_number_of_atoms</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_pbc" title="matscipy.opls.OPLSStructure.get_pbc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_pbc</span></code></a>()</p></td>
<td><p>Get periodic boundary condition flags.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_positions" title="matscipy.opls.OPLSStructure.get_positions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_positions</span></code></a>([wrap])</p></td>
<td><p>Get array of positions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_potential_energies" title="matscipy.opls.OPLSStructure.get_potential_energies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_potential_energies</span></code></a>()</p></td>
<td><p>Calculate the potential energies of all the atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_potential_energy" title="matscipy.opls.OPLSStructure.get_potential_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_potential_energy</span></code></a>([force_consistent, ...])</p></td>
<td><p>Calculate potential energy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_properties" title="matscipy.opls.OPLSStructure.get_properties"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_properties</span></code></a>(properties)</p></td>
<td><p>This method is experimental; currently for internal use.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_reciprocal_cell" title="matscipy.opls.OPLSStructure.get_reciprocal_cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_reciprocal_cell</span></code></a>()</p></td>
<td><p>Get the three reciprocal lattice vectors as a 3x3 ndarray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_scaled_positions" title="matscipy.opls.OPLSStructure.get_scaled_positions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaled_positions</span></code></a>([wrap])</p></td>
<td><p>Get positions relative to unit cell.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_stress" title="matscipy.opls.OPLSStructure.get_stress"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_stress</span></code></a>([voigt, apply_constraint, ...])</p></td>
<td><p>Calculate stress tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_stresses" title="matscipy.opls.OPLSStructure.get_stresses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_stresses</span></code></a>([include_ideal_gas, voigt])</p></td>
<td><p>Calculate the stress-tensor of all the atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_tags" title="matscipy.opls.OPLSStructure.get_tags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_tags</span></code></a>()</p></td>
<td><p>Get integer array of tags.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_temperature" title="matscipy.opls.OPLSStructure.get_temperature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_temperature</span></code></a>()</p></td>
<td><p>Get the temperature in Kelvin.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_total_energy" title="matscipy.opls.OPLSStructure.get_total_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_total_energy</span></code></a>()</p></td>
<td><p>Get the total energy - potential plus kinetic energy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_types" title="matscipy.opls.OPLSStructure.get_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_types</span></code></a>()</p></td>
<td><p>Returns a unique list of atom types.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_velocities" title="matscipy.opls.OPLSStructure.get_velocities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_velocities</span></code></a>()</p></td>
<td><p>Get array of velocities.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.get_volume" title="matscipy.opls.OPLSStructure.get_volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_volume</span></code></a>()</p></td>
<td><p>Get volume of unit cell.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.has" title="matscipy.opls.OPLSStructure.has"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has</span></code></a>(name)</p></td>
<td><p>Check for existence of array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.new_array" title="matscipy.opls.OPLSStructure.new_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new_array</span></code></a>(name, a[, dtype, shape])</p></td>
<td><p>Add new array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.pop" title="matscipy.opls.OPLSStructure.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>([i])</p></td>
<td><p>Remove and return atom at index <em>i</em> (default last).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.rattle" title="matscipy.opls.OPLSStructure.rattle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rattle</span></code></a>([stdev, seed, rng])</p></td>
<td><p>Randomly displace atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.repeat" title="matscipy.opls.OPLSStructure.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(rep)</p></td>
<td><p>Create new repeated atoms object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.rotate" title="matscipy.opls.OPLSStructure.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code></a>(a, v[, center, rotate_cell])</p></td>
<td><p>Rotate atoms based on a vector and an angle, or two vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.rotate_dihedral" title="matscipy.opls.OPLSStructure.rotate_dihedral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_dihedral</span></code></a>(a1, a2, a3, a4, angle[, ...])</p></td>
<td><p>Rotate dihedral angle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_angle" title="matscipy.opls.OPLSStructure.set_angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_angle</span></code></a>(a1[, a2, a3, angle, mask, ...])</p></td>
<td><p>Set angle (in degrees) formed by three atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_array" title="matscipy.opls.OPLSStructure.set_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_array</span></code></a>(name, a[, dtype, shape])</p></td>
<td><p>Update array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_atom_data" title="matscipy.opls.OPLSStructure.set_atom_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_atom_data</span></code></a>(atom_data)</p></td>
<td><p>Set Lennard-Jones parameters and atomic charges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_atomic_numbers" title="matscipy.opls.OPLSStructure.set_atomic_numbers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_atomic_numbers</span></code></a>(numbers)</p></td>
<td><p>Set atomic numbers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_calculator" title="matscipy.opls.OPLSStructure.set_calculator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_calculator</span></code></a>([calc])</p></td>
<td><p>Attach calculator object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_cell" title="matscipy.opls.OPLSStructure.set_cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_cell</span></code></a>(cell[, scale_atoms, apply_constraint])</p></td>
<td><p>Set unit cell vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_celldisp" title="matscipy.opls.OPLSStructure.set_celldisp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_celldisp</span></code></a>(celldisp)</p></td>
<td><p>Set the unit cell displacement vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_center_of_mass" title="matscipy.opls.OPLSStructure.set_center_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_center_of_mass</span></code></a>(com[, scaled])</p></td>
<td><p>Set the center of mass.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_chemical_symbols" title="matscipy.opls.OPLSStructure.set_chemical_symbols"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_chemical_symbols</span></code></a>(symbols)</p></td>
<td><p>Set chemical symbols.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_constraint" title="matscipy.opls.OPLSStructure.set_constraint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_constraint</span></code></a>([constraint])</p></td>
<td><p>Apply one or more constrains.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_cutoffs" title="matscipy.opls.OPLSStructure.set_cutoffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_cutoffs</span></code></a>(cutoffs)</p></td>
<td><p>Add a CutoffList object to the structure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_dihedral" title="matscipy.opls.OPLSStructure.set_dihedral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_dihedral</span></code></a>(a1, a2, a3, a4, angle[, mask, ...])</p></td>
<td><p>Set the dihedral angle (degrees) between vectors a1-&gt;a2 and a3-&gt;a4 by changing the atom indexed by a4.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_distance" title="matscipy.opls.OPLSStructure.set_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_distance</span></code></a>(a0, a1, distance[, fix, mic, ...])</p></td>
<td><p>Set the distance between two atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_initial_charges" title="matscipy.opls.OPLSStructure.set_initial_charges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_initial_charges</span></code></a>([charges])</p></td>
<td><p>Set the initial charges.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_initial_magnetic_moments" title="matscipy.opls.OPLSStructure.set_initial_magnetic_moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_initial_magnetic_moments</span></code></a>([magmoms])</p></td>
<td><p>Set the initial magnetic moments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_masses" title="matscipy.opls.OPLSStructure.set_masses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_masses</span></code></a>([masses])</p></td>
<td><p>Set atomic masses in atomic mass units.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_momenta" title="matscipy.opls.OPLSStructure.set_momenta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_momenta</span></code></a>(momenta[, apply_constraint])</p></td>
<td><p>Set momenta.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_pbc" title="matscipy.opls.OPLSStructure.set_pbc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_pbc</span></code></a>(pbc)</p></td>
<td><p>Set periodic boundary condition flags.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_positions" title="matscipy.opls.OPLSStructure.set_positions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_positions</span></code></a>(newpositions[, apply_constraint])</p></td>
<td><p>Set positions, honoring any constraints.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_scaled_positions" title="matscipy.opls.OPLSStructure.set_scaled_positions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_scaled_positions</span></code></a>(scaled)</p></td>
<td><p>Set positions relative to unit cell.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_tags" title="matscipy.opls.OPLSStructure.set_tags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_tags</span></code></a>(tags)</p></td>
<td><p>Set tags for all atoms.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_types" title="matscipy.opls.OPLSStructure.set_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_types</span></code></a>(types)</p></td>
<td><p>Set a type for each atom to specify the interaction with its neighbors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.set_velocities" title="matscipy.opls.OPLSStructure.set_velocities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_velocities</span></code></a>(velocities)</p></td>
<td><p>Set the momenta by specifying the velocities.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.todict" title="matscipy.opls.OPLSStructure.todict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">todict</span></code></a>()</p></td>
<td><p>For basic JSON (non-database) support.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.translate" title="matscipy.opls.OPLSStructure.translate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate</span></code></a>(displacement)</p></td>
<td><p>Translate atomic positions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.wrap" title="matscipy.opls.OPLSStructure.wrap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code></a>(**wrap_kw)</p></td>
<td><p>Wrap positions to unit cell.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matscipy.opls.OPLSStructure.write" title="matscipy.opls.OPLSStructure.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(filename[, format])</p></td>
<td><p>Write atoms object to a file.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>iterimages</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.default_map">
<span class="sig-name descname"><span class="pre">default_map</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'Al':</span> <span class="pre">'Al',</span> <span class="pre">'Ar':</span> <span class="pre">'Ar',</span> <span class="pre">'BR':</span> <span class="pre">'Br',</span> <span class="pre">'Be':</span> <span class="pre">'Be',</span> <span class="pre">'C0':</span> <span class="pre">'Ca',</span> <span class="pre">'Li':</span> <span class="pre">'Li',</span> <span class="pre">'Mg':</span> <span class="pre">'Mg'}</span></em><a class="headerlink" href="#matscipy.opls.OPLSStructure.default_map" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.__init__" title="Link to this definition"></a></dt>
<dd><p>Set a type for each atom to specify the interaction with its neighbors.
This enables atoms of the same element to have different interaction
potentials. During initialization, the types are initially derived from
the chemical symbols of the atoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.append" title="Link to this definition"></a></dt>
<dd><p>Append atom to the end.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atom</strong> (<em>ase.Atoms</em>) – The particle to append.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_types">
<span class="sig-name descname"><span class="pre">set_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">types</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_types" title="Link to this definition"></a></dt>
<dd><p>Set a type for each atom to specify the interaction with its
neighbors. This enables atoms of the same element to have
different interaction potentials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>types</strong> (<em>list</em>) – A list of strings that specify the type of each atom.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_types">
<span class="sig-name descname"><span class="pre">get_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_types" title="Link to this definition"></a></dt>
<dd><p>Returns a unique list of atom types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Particle types. Each element is a <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> with two
characters.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_cutoffs">
<span class="sig-name descname"><span class="pre">set_cutoffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoffs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_cutoffs" title="Link to this definition"></a></dt>
<dd><p>Add a CutoffList object to the structure. This allows the
<a class="reference internal" href="#matscipy.opls.OPLSStructure.get_neighbors" title="matscipy.opls.OPLSStructure.get_neighbors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matscipy.opls.OPLSStructure.get_neighbors()</span></code></a> method
to find all interacting atoms of the structure based on a
simple distance criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cutoffs</strong> (<a class="reference internal" href="#matscipy.opls.CutoffList" title="matscipy.opls.CutoffList"><em>opls.CutoffList</em></a>) – Cutoffs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_neighbors">
<span class="sig-name descname"><span class="pre">get_neighbors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_neighbors" title="Link to this definition"></a></dt>
<dd><p>Find all atoms which might interact with each
other based on a simple distance criterion.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_atom_data">
<span class="sig-name descname"><span class="pre">set_atom_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom_data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_atom_data" title="Link to this definition"></a></dt>
<dd><p>Set Lennard-Jones parameters and atomic charges. Notice that each
atom has exactly one set of Lennard-Jones parameters. Parameters
for interactions between different types of atoms are calculated
by geometric mixing. See documentation of the LAMMPS
<code class="docutils literal notranslate"><span class="pre">pair_modify</span></code> command for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atom_data</strong> (<em>dict</em>) – Dictionary containing Lennard-Jones parameters and charges for
each particle type. key: <code class="docutils literal notranslate"><span class="pre">Particle</span> <span class="pre">type</span></code>, one or two
characters, value: <code class="docutils literal notranslate"><span class="pre">[LJ-epsilon,</span> <span class="pre">LJ-sigma,</span> <span class="pre">charge]</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_charges">
<span class="sig-name descname"><span class="pre">get_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_charges" title="Link to this definition"></a></dt>
<dd><p>Return an array of atomic charges. Same functionality as the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ase.Atoms.get_charges()</span></code> method, but atomic charges are
taken from a user definition instead of the result of a
calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Particle charges.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_bonds">
<span class="sig-name descname"><span class="pre">get_bonds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bonds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_bonds" title="Link to this definition"></a></dt>
<dd><p>Returns an array of all bond types and an array of all bonds
in the system. This method also checks if potential parameters
for all found bonds are present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bonds</strong> (<a class="reference internal" href="#matscipy.opls.BondData" title="matscipy.opls.BondData"><em>opls.BondData</em></a><em>, </em><em>optional</em>) – Pairwise potential parameters. Can be set here or elsewhere
in the code, e.g. by setting the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matscipy.opls.OPLSStructure.bonds</span></code>. If it is present,
this method runs a test to check if interaction parameters
are defined for all present bonds.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>bond_types</strong> (<em>numpy.ndarray</em>) – Array of strings characterizing all present bond types.
Example: A system consists of particles with the types
<code class="docutils literal notranslate"><span class="pre">A1</span></code> and <code class="docutils literal notranslate"><span class="pre">A2</span></code>. If all particles interact with each
other, <code class="docutils literal notranslate"><span class="pre">bond_types</span></code> will be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;A1-A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A1-A2&#39;</span><span class="p">,</span> <span class="s1">&#39;A2-A2&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>If there were no interactions between the types <code class="docutils literal notranslate"><span class="pre">A1</span></code>
and <code class="docutils literal notranslate"><span class="pre">A2</span></code>, <code class="docutils literal notranslate"><span class="pre">bond_types</span></code> would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;A1-A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A2-A2&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><strong>bond_list</strong> (<em>numpy.ndarray</em>) – <code class="docutils literal notranslate"><span class="pre">bond_list.shape</span> <span class="pre">=</span> <span class="pre">(n,</span> <span class="pre">3)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number
of particles in the system. Contains arrays of 3 integers
for each bond in the system. First number: interaction
type, index of <code class="docutils literal notranslate"><span class="pre">bond_types</span></code>, second and third numbers:
indicees of participating particles.
Example: A system consists of 3 particles of type <code class="docutils literal notranslate"><span class="pre">AA</span></code>,
all particles are interacting. bond_types would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;AA-AA&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>and bond_list would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If <code class="docutils literal notranslate"><span class="pre">self.bonds</span></code> is present and bonds are found for which
no parameters are defined. In this case a warning a full
list of all affected bonds will be printed on <code class="docutils literal notranslate"><span class="pre">STDOUT</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_angles">
<span class="sig-name descname"><span class="pre">get_angles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_angles" title="Link to this definition"></a></dt>
<dd><p>Returns an array of all angle types and an array of all
angles in the system. This method also checks if potential
parameters for all found angles are present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>angles</strong> (<a class="reference internal" href="#matscipy.opls.AnglesData" title="matscipy.opls.AnglesData"><em>opls.AnglesData</em></a><em>, </em><em>optional</em>) – Potential parameters. Can be set here or elsewhere in the
code, e.g. by setting the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matscipy.opls.OPLSStructure.angles</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>ang_types</strong> (<em>list</em>) – Array of strings characterizing all present angle types.
Example: A system consists of atoms of types <code class="docutils literal notranslate"><span class="pre">A1</span></code> and
<code class="docutils literal notranslate"><span class="pre">A2</span></code>, all conceivable angle types are present in the
system. <code class="docutils literal notranslate"><span class="pre">ang_types</span></code> would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;A1-A1-A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A1-A1-A2&#39;</span><span class="p">,</span> <span class="s1">&#39;A1-A2-A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A1-A2-A2&#39;</span><span class="p">,</span> <span class="s1">&#39;A2-A1-A2&#39;</span><span class="p">,</span> <span class="s1">&#39;A2-A2-A2&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><strong>ang_list</strong> (<em>list</em>) – <code class="docutils literal notranslate"><span class="pre">len(ang_list)</span> <span class="pre">=</span> <span class="pre">n</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of particles
in the system. Each list entry is a list of 4 integers,
characterizing the angles present in the system.
Example:
A system contains 7 atoms, <code class="docutils literal notranslate"><span class="pre">(0,1,2)</span></code> of type <code class="docutils literal notranslate"><span class="pre">A1</span></code> and
<code class="docutils literal notranslate"><span class="pre">(3,4,5,6)</span></code> of type <code class="docutils literal notranslate"><span class="pre">A2</span></code>. If there are angles between
<code class="docutils literal notranslate"><span class="pre">(0,1,2)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,3,4)</span></code> and <code class="docutils literal notranslate"><span class="pre">(0,5,6)</span></code>, <code class="docutils literal notranslate"><span class="pre">ang_list</span></code>
would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;A1-A1-A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A2-A1-A2&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">ang_list</span></code> would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> – If <code class="docutils literal notranslate"><span class="pre">self.angles</span></code> is present and angles are found for which
no parameters are defined. In this case a warning a full list
of all affected angles will be printed on <code class="docutils literal notranslate"><span class="pre">STDOUT</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.ase_objtype">
<span class="sig-name descname"><span class="pre">ase_objtype</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'atoms'</span></em><a class="headerlink" href="#matscipy.opls.OPLSStructure.ase_objtype" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.calc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">calc</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.calc" title="Link to this definition"></a></dt>
<dd><p>Calculator object.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.cell" title="Link to this definition"></a></dt>
<dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.cell.Cell</span></code> for direct manipulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vacuum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">about</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.center" title="Link to this definition"></a></dt>
<dd><p>Center atoms in unit cell.</p>
<p>Centers the atoms in the unit cell, so there is the same
amount of vacuum on all sides.</p>
<dl class="simple">
<dt>vacuum: float (default: None)</dt><dd><p>If specified adjust the amount of vacuum when centering.
If vacuum=10.0 there will thus be 10 Angstrom of vacuum
on each side.</p>
</dd>
<dt>axis: int or sequence of ints</dt><dd><p>Axis or axes to act on.  Default: Act on all axes.</p>
</dd>
<dt>about: float or array (default: None)</dt><dd><p>If specified, center the atoms about &lt;about&gt;.
I.e., about=(0., 0., 0.) (or just “about=0.”, interpreted
identically), to center about the origin.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.constraints">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">constraints</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.constraints" title="Link to this definition"></a></dt>
<dd><p>Constraints of the atoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.copy" title="Link to this definition"></a></dt>
<dd><p>Return a copy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.edit">
<span class="sig-name descname"><span class="pre">edit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.edit" title="Link to this definition"></a></dt>
<dd><p>Modify atoms interactively through ASE’s GUI viewer.</p>
<p>Conflicts leading to undesirable behaviour might arise
when matplotlib has been pre-imported with certain
incompatible backends and while trying to use the
plot feature inside the interactive GUI. To circumvent,
please set matplotlib.use(‘gtk’) before calling this
method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.euler_rotate">
<span class="sig-name descname"><span class="pre">euler_rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.euler_rotate" title="Link to this definition"></a></dt>
<dd><p>Rotate atoms via Euler angles (in degrees).</p>
<p>See e.g <a class="reference external" href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> for explanation.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>center :</dt><dd><p>The point to rotate about. A sequence of length 3 with the
coordinates, or ‘COM’ to select the center of mass, ‘COP’ to
select center of positions or ‘COU’ to select center of cell.</p>
</dd>
<dt>phi :</dt><dd><p>The 1st rotation angle around the z axis.</p>
</dd>
<dt>theta :</dt><dd><p>Rotation around the x axis.</p>
</dd>
<dt>psi :</dt><dd><p>2nd rotation around the z axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.extend" title="Link to this definition"></a></dt>
<dd><p>Extend atoms object by appending atoms from <em>other</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.fromdict">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dct</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.fromdict" title="Link to this definition"></a></dt>
<dd><p>Rebuild atoms object from dictionary representation (todict).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_all_distances">
<span class="sig-name descname"><span class="pre">get_all_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_all_distances" title="Link to this definition"></a></dt>
<dd><p>Return distances of all of the atoms with all of the atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_angle">
<span class="sig-name descname"><span class="pre">get_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_angle" title="Link to this definition"></a></dt>
<dd><p>Get angle formed by three atoms.</p>
<p>Calculate angle in degrees between the vectors a2-&gt;a1 and
a2-&gt;a3.</p>
<p>Use mic=True to use the Minimum Image Convention and calculate the
angle across periodic boundaries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_angular_momentum">
<span class="sig-name descname"><span class="pre">get_angular_momentum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_angular_momentum" title="Link to this definition"></a></dt>
<dd><p>Get total angular momentum with respect to the center of mass.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_array">
<span class="sig-name descname"><span class="pre">get_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_array" title="Link to this definition"></a></dt>
<dd><p>Get an array.</p>
<p>Returns a copy unless the optional argument copy is false.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_atomic_numbers">
<span class="sig-name descname"><span class="pre">get_atomic_numbers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_atomic_numbers" title="Link to this definition"></a></dt>
<dd><p>Get integer array of atomic numbers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_calculator">
<span class="sig-name descname"><span class="pre">get_calculator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_calculator" title="Link to this definition"></a></dt>
<dd><p>Get currently attached calculator object.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.20.0: </span>Please use the equivalent <code class="docutils literal notranslate"><span class="pre">atoms.calc</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">atoms.get_calculator()</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_cell">
<span class="sig-name descname"><span class="pre">get_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_cell" title="Link to this definition"></a></dt>
<dd><p>Get the three unit cell vectors as a <cite>class</cite>:ase.cell.Cell` object.</p>
<p>The Cell object resembles a 3x3 ndarray, and cell[i, j]
is the jth Cartesian coordinate of the ith cell vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_cell_lengths_and_angles">
<span class="sig-name descname"><span class="pre">get_cell_lengths_and_angles</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_cell_lengths_and_angles" title="Link to this definition"></a></dt>
<dd><p>Get unit cell parameters. Sequence of 6 numbers.</p>
<p>First three are unit cell vector lengths and second three
are angles between them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">angle</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="n">angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="n">angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
</pre></div>
</div>
<p>in degrees.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.21.0: </span>Please use <code class="docutils literal notranslate"><span class="pre">atoms.cell.cellpar()</span></code> instead</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_celldisp">
<span class="sig-name descname"><span class="pre">get_celldisp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_celldisp" title="Link to this definition"></a></dt>
<dd><p>Get the unit cell displacement vectors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_center_of_mass">
<span class="sig-name descname"><span class="pre">get_center_of_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_center_of_mass" title="Link to this definition"></a></dt>
<dd><p>Get the center of mass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scaled</strong> (<em>bool</em>) – If True, the center of mass in scaled coordinates is returned.</p></li>
<li><p><strong>indices</strong> (<em>list</em><em> | </em><em>slice</em><em> | </em><em>str</em><em>, </em><em>default: None</em>) – If specified, the center of mass of a subset of atoms is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_chemical_formula">
<span class="sig-name descname"><span class="pre">get_chemical_formula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hill'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">empirical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_chemical_formula" title="Link to this definition"></a></dt>
<dd><p>Get the chemical formula as a string based on the chemical symbols.</p>
<p>Parameters:</p>
<dl>
<dt>mode: str</dt><dd><p>There are four different modes available:</p>
<p>‘all’: The list of chemical symbols are contracted to a string,
e.g. [‘C’, ‘H’, ‘H’, ‘H’, ‘O’, ‘H’] becomes ‘CHHHOH’.</p>
<p>‘reduce’: The same as ‘all’ where repeated elements are contracted
to a single symbol and a number, e.g. ‘CHHHOCHHH’ is reduced to
‘CH3OCH3’.</p>
<p>‘hill’: The list of chemical symbols are contracted to a string
following the Hill notation (alphabetical order with C and H
first), e.g. ‘CHHHOCHHH’ is reduced to ‘C2H6O’ and ‘SOOHOHO’ to
‘H2O4S’. This is default.</p>
<p>‘metal’: The list of chemical symbols (alphabetical metals,
and alphabetical non-metals)</p>
</dd>
<dt>empirical, bool (optional, default=False)</dt><dd><p>Divide the symbol counts by their greatest common divisor to yield
an empirical formula. Only for mode <cite>metal</cite> and <cite>hill</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_chemical_symbols">
<span class="sig-name descname"><span class="pre">get_chemical_symbols</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_chemical_symbols" title="Link to this definition"></a></dt>
<dd><p>Get list of chemical symbol strings.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">list(atoms.symbols)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_dihedral">
<span class="sig-name descname"><span class="pre">get_dihedral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_dihedral" title="Link to this definition"></a></dt>
<dd><p>Calculate dihedral angle.</p>
<p>Calculate dihedral angle (in degrees) between the vectors a0-&gt;a1
and a2-&gt;a3.</p>
<p>Use mic=True to use the Minimum Image Convention and calculate the
angle across periodic boundaries.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_dihedrals">
<span class="sig-name descname"><span class="pre">get_dihedrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dihedrals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_dihedrals" title="Link to this definition"></a></dt>
<dd><p>Returns an array of all dihedral types and an array of all
dihedrals in the system. This method also checks if potential
parameters for all found dihedrals are present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dihedrals</strong> (<a class="reference internal" href="#matscipy.opls.DihedralsData" title="matscipy.opls.DihedralsData"><em>opls.DihedralsData</em></a><em>, </em><em>optional</em>) – Potential parameters. Can be set here or elsewhere in the
code, e.g. by setting the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">matscipy.opls.OPLSStructure.dihedrals</span></code>.</p></li>
<li><p><strong>full_output</strong> (<em>bool</em><em>, </em><em>optional</em>) – Print a full list of all found dihedrals on <code class="docutils literal notranslate"><span class="pre">STDOUT</span></code> for
which no potential parameters are defined. By default, only
one example is printed. Having the full list is sometimes
helpful for debugging.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>dih_types</strong> (<em>list</em>) – Array of strings characterizing all present dihedral types.
Example: Consider a system consisting of one benzene molecule.
There are three possible types of dihedrals and <code class="docutils literal notranslate"><span class="pre">dih_type</span></code>
would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;C-C-C-C&#39;</span><span class="p">,</span> <span class="s1">&#39;C-C-C-H&#39;</span><span class="p">,</span> <span class="s1">&#39;H-C-C-H&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><strong>dih_list</strong> (<em>list</em>) – <code class="docutils literal notranslate"><span class="pre">len(dih_list)</span> <span class="pre">=</span> <span class="pre">n</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of particles in the
system. Each list entry is a list of 5 integers, characterizing the
dihedrals present in the system.
Example: Consider a system consisting of one benzene molecule with
the <code class="docutils literal notranslate"><span class="pre">C</span></code> atoms <code class="docutils literal notranslate"><span class="pre">(0,1,2,3,4,5)</span></code> and the <code class="docutils literal notranslate"><span class="pre">H</span></code> atoms
<code class="docutils literal notranslate"><span class="pre">(6,7,8,9,10,11)</span></code>. <code class="docutils literal notranslate"><span class="pre">dih_type</span></code> would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;C-C-C-C&#39;</span><span class="p">,</span> <span class="s1">&#39;C-C-C-H&#39;</span><span class="p">,</span> <span class="s1">&#39;H-C-C-H&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">dih_list</span></code> would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="o">...</span> <span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">...</span> <span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_dipole_moment">
<span class="sig-name descname"><span class="pre">get_dipole_moment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_dipole_moment" title="Link to this definition"></a></dt>
<dd><p>Calculate the electric dipole moment for the atoms object.</p>
<p>Only available for calculators which has a get_dipole_moment()
method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_distance">
<span class="sig-name descname"><span class="pre">get_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_distance" title="Link to this definition"></a></dt>
<dd><p>Return distance between two atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a0 to a1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_distances">
<span class="sig-name descname"><span class="pre">get_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_distances" title="Link to this definition"></a></dt>
<dd><p>Return distances of atom No.i with a list of atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a to self[indices]).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_forces">
<span class="sig-name descname"><span class="pre">get_forces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">md</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_forces" title="Link to this definition"></a></dt>
<dd><p>Calculate atomic forces.</p>
<p>Ask the attached calculator to calculate the forces and apply
constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
<p>For molecular dynamics (md=True) we don’t apply the constraint
to the forces but to the momenta. When holonomic constraints for
rigid linear triatomic molecules are present, ask the constraints
to redistribute the forces within each triple defined in the
constraints (required for molecular dynamics with this type of
constraints).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_global_number_of_atoms">
<span class="sig-name descname"><span class="pre">get_global_number_of_atoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_global_number_of_atoms" title="Link to this definition"></a></dt>
<dd><p>Returns the global number of atoms in a distributed-atoms parallel
simulation.</p>
<p>DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING!</p>
<p>Equivalent to len(atoms) in the standard ASE Atoms class.  You should
normally use len(atoms) instead.  This function’s only purpose is to
make compatibility between ASE and Asap easier to maintain by having a
few places in ASE use this function instead.  It is typically only
when counting the global number of degrees of freedom or in similar
situations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_initial_charges">
<span class="sig-name descname"><span class="pre">get_initial_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_initial_charges" title="Link to this definition"></a></dt>
<dd><p>Get array of initial charges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_initial_magnetic_moments">
<span class="sig-name descname"><span class="pre">get_initial_magnetic_moments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_initial_magnetic_moments" title="Link to this definition"></a></dt>
<dd><p>Get array of initial magnetic moments.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_kinetic_energy">
<span class="sig-name descname"><span class="pre">get_kinetic_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_kinetic_energy" title="Link to this definition"></a></dt>
<dd><p>Get the kinetic energy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_magnetic_moment">
<span class="sig-name descname"><span class="pre">get_magnetic_moment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_magnetic_moment" title="Link to this definition"></a></dt>
<dd><p>Get calculated total magnetic moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_magnetic_moments">
<span class="sig-name descname"><span class="pre">get_magnetic_moments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_magnetic_moments" title="Link to this definition"></a></dt>
<dd><p>Get calculated local magnetic moments.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_masses">
<span class="sig-name descname"><span class="pre">get_masses</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_masses" title="Link to this definition"></a></dt>
<dd><p>Get array of masses in atomic mass units.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_momenta">
<span class="sig-name descname"><span class="pre">get_momenta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_momenta" title="Link to this definition"></a></dt>
<dd><p>Get array of momenta.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_moments_of_inertia">
<span class="sig-name descname"><span class="pre">get_moments_of_inertia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_moments_of_inertia" title="Link to this definition"></a></dt>
<dd><p>Get the moments of inertia along the principal axes.</p>
<p>The three principal moments of inertia are computed from the
eigenvalues of the symmetric inertial tensor. Periodic boundary
conditions are ignored. Units of the moments of inertia are
amu*angstrom**2.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_number_of_atoms">
<span class="sig-name descname"><span class="pre">get_number_of_atoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_number_of_atoms" title="Link to this definition"></a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.18.1: </span>You probably want <code class="docutils literal notranslate"><span class="pre">len(atoms)</span></code>.  Or if your atoms are distributed,
use (and see) <a class="reference internal" href="#matscipy.opls.OPLSStructure.get_global_number_of_atoms" title="matscipy.opls.OPLSStructure.get_global_number_of_atoms"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_global_number_of_atoms()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_pbc">
<span class="sig-name descname"><span class="pre">get_pbc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_pbc" title="Link to this definition"></a></dt>
<dd><p>Get periodic boundary condition flags.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_positions">
<span class="sig-name descname"><span class="pre">get_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">wrap_kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_positions" title="Link to this definition"></a></dt>
<dd><p>Get array of positions.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>wrap: bool</dt><dd><p>wrap atoms back to the cell before returning positions</p>
</dd>
<dt>wrap_kw: (keyword=value) pairs</dt><dd><p>optional keywords <cite>pbc</cite>, <cite>center</cite>, <cite>pretty_translation</cite>, <cite>eps</cite>,
see <code class="xref py py-func docutils literal notranslate"><span class="pre">ase.geometry.wrap_positions()</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_potential_energies">
<span class="sig-name descname"><span class="pre">get_potential_energies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_potential_energies" title="Link to this definition"></a></dt>
<dd><p>Calculate the potential energies of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies
(e.g. classical potentials).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_potential_energy">
<span class="sig-name descname"><span class="pre">get_potential_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force_consistent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_potential_energy" title="Link to this definition"></a></dt>
<dd><p>Calculate potential energy.</p>
<p>Ask the attached calculator to calculate the potential energy and
apply constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
<p>When supported by the calculator, either the energy extrapolated
to zero Kelvin or the energy consistent with the forces (the free
energy) can be returned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_properties">
<span class="sig-name descname"><span class="pre">get_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">properties</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_properties" title="Link to this definition"></a></dt>
<dd><p>This method is experimental; currently for internal use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_reciprocal_cell">
<span class="sig-name descname"><span class="pre">get_reciprocal_cell</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_reciprocal_cell" title="Link to this definition"></a></dt>
<dd><p>Get the three reciprocal lattice vectors as a 3x3 ndarray.</p>
<p>Note that the commonly used factor of 2 pi for Fourier
transforms is not included here.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.21.0: </span>Please use <code class="docutils literal notranslate"><span class="pre">atoms.cell.reciprocal()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_scaled_positions">
<span class="sig-name descname"><span class="pre">get_scaled_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_scaled_positions" title="Link to this definition"></a></dt>
<dd><p>Get positions relative to unit cell.</p>
<p>If wrap is True, atoms outside the unit cell will be wrapped into
the cell in those directions with periodic boundary conditions
so that the scaled coordinates are between zero and one.</p>
<p>If any cell vectors are zero, the corresponding coordinates
are evaluated as if the cell were completed using
<code class="docutils literal notranslate"><span class="pre">cell.complete()</span></code>.  This means coordinates will be Cartesian
as long as the non-zero cell vectors span a Cartesian axis or
plane.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_stress">
<span class="sig-name descname"><span class="pre">get_stress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voigt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_ideal_gas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_stress" title="Link to this definition"></a></dt>
<dd><p>Calculate stress tensor.</p>
<p>Returns an array of the six independent components of the
symmetric stress tensor, in the traditional Voigt order
(xx, yy, zz, yz, xz, xy) or as a 3x3 matrix.  Default is Voigt
order.</p>
<p>The ideal gas contribution to the stresses is added if the
atoms have momenta and <code class="docutils literal notranslate"><span class="pre">include_ideal_gas</span></code> is set to True.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_stresses">
<span class="sig-name descname"><span class="pre">get_stresses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">include_ideal_gas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voigt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_stresses" title="Link to this definition"></a></dt>
<dd><p>Calculate the stress-tensor of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies and
stresses (e.g. classical potentials).  Even for such calculators
there is a certain arbitrariness in defining per-atom stresses.</p>
<p>The ideal gas contribution to the stresses is added if the
atoms have momenta and <code class="docutils literal notranslate"><span class="pre">include_ideal_gas</span></code> is set to True.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_tags">
<span class="sig-name descname"><span class="pre">get_tags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_tags" title="Link to this definition"></a></dt>
<dd><p>Get integer array of tags.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_temperature">
<span class="sig-name descname"><span class="pre">get_temperature</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_temperature" title="Link to this definition"></a></dt>
<dd><p>Get the temperature in Kelvin.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_total_energy">
<span class="sig-name descname"><span class="pre">get_total_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_total_energy" title="Link to this definition"></a></dt>
<dd><p>Get the total energy - potential plus kinetic energy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_velocities">
<span class="sig-name descname"><span class="pre">get_velocities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_velocities" title="Link to this definition"></a></dt>
<dd><p>Get array of velocities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.get_volume">
<span class="sig-name descname"><span class="pre">get_volume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.get_volume" title="Link to this definition"></a></dt>
<dd><p>Get volume of unit cell.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.has">
<span class="sig-name descname"><span class="pre">has</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.has" title="Link to this definition"></a></dt>
<dd><p>Check for existence of array.</p>
<p>name must be one of: ‘tags’, ‘momenta’, ‘masses’, ‘initial_magmoms’,
‘initial_charges’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.iterimages">
<span class="sig-name descname"><span class="pre">iterimages</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.iterimages" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.new_array">
<span class="sig-name descname"><span class="pre">new_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.new_array" title="Link to this definition"></a></dt>
<dd><p>Add new array.</p>
<p>If <em>shape</em> is not <em>None</em>, the shape of <em>a</em> will be checked.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.number_of_lattice_vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">number_of_lattice_vectors</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.number_of_lattice_vectors" title="Link to this definition"></a></dt>
<dd><p>Number of (non-zero) lattice vectors.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.21.0: </span>Please use <code class="docutils literal notranslate"><span class="pre">atoms.cell.rank</span></code> instead</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.numbers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">numbers</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.numbers" title="Link to this definition"></a></dt>
<dd><p>Attribute for direct manipulation of the atomic numbers.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.pbc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pbc</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.pbc" title="Link to this definition"></a></dt>
<dd><p>Reference to pbc-flags for in-place manipulations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.pop" title="Link to this definition"></a></dt>
<dd><p>Remove and return atom at index <em>i</em> (default last).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.positions" title="Link to this definition"></a></dt>
<dd><p>Attribute for direct manipulation of the positions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.rattle">
<span class="sig-name descname"><span class="pre">rattle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stdev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.rattle" title="Link to this definition"></a></dt>
<dd><p>Randomly displace atoms.</p>
<p>This method adds random displacements to the atomic positions,
taking a possible constraint into account. The random numbers are
drawn from a normal distribution of standard deviation stdev.</p>
<p>By default, the random number generator always uses the same seed (42)
for repeatability. You can provide your own seed (an integer), or if you
want the randomness to be different each time you run a script, then
provide <cite>rng=numpy.random</cite>. For a parallel calculation, it is important
to use the same seed on all processors!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.repeat">
<span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.repeat" title="Link to this definition"></a></dt>
<dd><p>Create new repeated atoms object.</p>
<p>The <em>rep</em> argument should be a sequence of three positive
integers like <em>(2,3,1)</em> or a single integer (<em>r</em>) equivalent
to <em>(r,r,r)</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate_cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.rotate" title="Link to this definition"></a></dt>
<dd><p>Rotate atoms based on a vector and an angle, or two vectors.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>a = None:</dt><dd><p>Angle that the atoms is rotated around the vector ‘v’. ‘a’
can also be a vector and then ‘a’ is rotated
into ‘v’.</p>
</dd>
<dt>v:</dt><dd><p>Vector to rotate the atoms around. Vectors can be given as
strings: ‘x’, ‘-x’, ‘y’, … .</p>
</dd>
<dt>center = (0, 0, 0):</dt><dd><p>The center is kept fixed under the rotation. Use ‘COM’ to fix
the center of mass, ‘COP’ to fix the center of positions or
‘COU’ to fix the center of cell.</p>
</dd>
<dt>rotate_cell = False:</dt><dd><p>If true the cell is also rotated.</p>
</dd>
</dl>
<p>Examples:</p>
<p>Rotate 90 degrees around the z-axis, so that the x-axis is
rotated into the y-axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="s1">&#39;-z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">rotate</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.rotate_dihedral">
<span class="sig-name descname"><span class="pre">rotate_dihedral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.rotate_dihedral" title="Link to this definition"></a></dt>
<dd><p>Rotate dihedral angle.</p>
<p>Same usage as in <code class="xref py py-meth docutils literal notranslate"><span class="pre">ase.Atoms.set_dihedral()</span></code>: Rotate a group by a
predefined dihedral angle, starting from its current configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_angle">
<span class="sig-name descname"><span class="pre">set_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_angle" title="Link to this definition"></a></dt>
<dd><p>Set angle (in degrees) formed by three atoms.</p>
<p>Sets the angle between vectors <em>a2</em>-&gt;*a1* and <em>a2</em>-&gt;*a3*.</p>
<p>If <em>add</em> is <cite>True</cite>, the angle will be changed by the value given.</p>
<p>Same usage as in <code class="xref py py-meth docutils literal notranslate"><span class="pre">ase.Atoms.set_dihedral()</span></code>.
If <em>mask</em> and <em>indices</em>
are given, <em>indices</em> overwrites <em>mask</em>. If <em>mask</em> and <em>indices</em>
are not set, only <em>a3</em> is moved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_array">
<span class="sig-name descname"><span class="pre">set_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_array" title="Link to this definition"></a></dt>
<dd><p>Update array.</p>
<p>If <em>shape</em> is not <em>None</em>, the shape of <em>a</em> will be checked.
If <em>a</em> is <em>None</em>, then the array is deleted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_atomic_numbers">
<span class="sig-name descname"><span class="pre">set_atomic_numbers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numbers</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_atomic_numbers" title="Link to this definition"></a></dt>
<dd><p>Set atomic numbers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_calculator">
<span class="sig-name descname"><span class="pre">set_calculator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_calculator" title="Link to this definition"></a></dt>
<dd><p>Attach calculator object.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.20.0: </span>Please use the equivalent <code class="docutils literal notranslate"><span class="pre">atoms.calc</span> <span class="pre">=</span> <span class="pre">calc</span></code> instead of this
method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_cell">
<span class="sig-name descname"><span class="pre">set_cell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_cell" title="Link to this definition"></a></dt>
<dd><p>Set unit cell vectors.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>cell: 3x3 matrix or length 3 or 6 vector</dt><dd><p>Unit cell.  A 3x3 matrix (the three unit cell vectors) or
just three numbers for an orthorhombic cell. Another option is
6 numbers, which describes unit cell with lengths of unit cell
vectors and with angles between them (in degrees), in following
order: [len(a), len(b), len(c), angle(b,c), angle(a,c),
angle(a,b)].  First vector will lie in x-direction, second in
xy-plane, and the third one in z-positive subspace.</p>
</dd>
<dt>scale_atoms: bool</dt><dd><p>Fix atomic positions or move atoms with the unit cell?
Default behavior is to <em>not</em> move the atoms (scale_atoms=False).</p>
</dd>
<dt>apply_constraint: bool</dt><dd><p>Whether to apply constraints to the given cell.</p>
</dd>
</dl>
<p>Examples:</p>
<p>Two equivalent ways to define an orthorhombic cell:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s1">&#39;He&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">,</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)])</span>
</pre></div>
</div>
<p>FCC unit cell:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
<p>Hexagonal unit cell:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">120</span><span class="p">])</span>
</pre></div>
</div>
<p>Rhombohedral unit cell:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">77</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">alpha</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_celldisp">
<span class="sig-name descname"><span class="pre">set_celldisp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">celldisp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_celldisp" title="Link to this definition"></a></dt>
<dd><p>Set the unit cell displacement vectors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_center_of_mass">
<span class="sig-name descname"><span class="pre">set_center_of_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">com</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_center_of_mass" title="Link to this definition"></a></dt>
<dd><p>Set the center of mass.</p>
<p>If scaled=True the center of mass is expected in scaled coordinates.
Constraints are considered for scaled=False.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_chemical_symbols">
<span class="sig-name descname"><span class="pre">set_chemical_symbols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_chemical_symbols" title="Link to this definition"></a></dt>
<dd><p>Set chemical symbols.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_constraint">
<span class="sig-name descname"><span class="pre">set_constraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_constraint" title="Link to this definition"></a></dt>
<dd><p>Apply one or more constrains.</p>
<p>The <em>constraint</em> argument must be one constraint object or a
list of constraint objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_dihedral">
<span class="sig-name descname"><span class="pre">set_dihedral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_dihedral" title="Link to this definition"></a></dt>
<dd><p>Set the dihedral angle (degrees) between vectors a1-&gt;a2 and
a3-&gt;a4 by changing the atom indexed by a4.</p>
<p>If mask is not None, all the atoms described in mask
(read: the entire subgroup) are moved. Alternatively to the mask,
the indices of the atoms to be rotated can be supplied. If both
<em>mask</em> and <em>indices</em> are given, <em>indices</em> overwrites <em>mask</em>.</p>
<p><strong>Important</strong>: If <em>mask</em> or <em>indices</em> is given and does not contain
<em>a4</em>, <em>a4</em> will NOT be moved. In most cases you therefore want
to include <em>a4</em> in <em>mask</em>/<em>indices</em>.</p>
<p>Example: the following defines a very crude
ethane-like molecule and twists one half of it by 30 degrees.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s1">&#39;HHCCHH&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_dihedral</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_distance">
<span class="sig-name descname"><span class="pre">set_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_distance" title="Link to this definition"></a></dt>
<dd><p>Set the distance between two atoms.</p>
<p>Set the distance between atoms <em>a0</em> and <em>a1</em> to <em>distance</em>.
By default, the center of the two atoms will be fixed.  Use
<em>fix=0</em> to fix the first atom, <em>fix=1</em> to fix the second
atom and <em>fix=0.5</em> (default) to fix the center of the bond.</p>
<p>If <em>mask</em> or <em>indices</em> are set (<em>mask</em> overwrites <em>indices</em>),
only the atoms defined there are moved
(see <code class="xref py py-meth docutils literal notranslate"><span class="pre">ase.Atoms.set_dihedral()</span></code>).</p>
<p>When <em>add</em> is true, the distance is changed by the value given.
In combination
with <em>factor</em> True, the value given is a factor scaling the distance.</p>
<p>It is assumed that the atoms in <em>mask</em>/<em>indices</em> move together
with <em>a1</em>. If <em>fix=1</em>, only <em>a0</em> will therefore be moved.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_initial_charges">
<span class="sig-name descname"><span class="pre">set_initial_charges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">charges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_initial_charges" title="Link to this definition"></a></dt>
<dd><p>Set the initial charges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_initial_magnetic_moments">
<span class="sig-name descname"><span class="pre">set_initial_magnetic_moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magmoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_initial_magnetic_moments" title="Link to this definition"></a></dt>
<dd><p>Set the initial magnetic moments.</p>
<p>Use either one or three numbers for every atom (collinear
or non-collinear spins).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_masses">
<span class="sig-name descname"><span class="pre">set_masses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">masses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'defaults'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_masses" title="Link to this definition"></a></dt>
<dd><p>Set atomic masses in atomic mass units.</p>
<p>The array masses should contain a list of masses.  In case
the masses argument is not given or for those elements of the
masses list that are None, standard values are set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_momenta">
<span class="sig-name descname"><span class="pre">set_momenta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">momenta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_momenta" title="Link to this definition"></a></dt>
<dd><p>Set momenta.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_pbc">
<span class="sig-name descname"><span class="pre">set_pbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pbc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_pbc" title="Link to this definition"></a></dt>
<dd><p>Set periodic boundary condition flags.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_positions">
<span class="sig-name descname"><span class="pre">set_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">newpositions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_positions" title="Link to this definition"></a></dt>
<dd><p>Set positions, honoring any constraints. To ignore constraints,
use <em>apply_constraint=False</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_scaled_positions">
<span class="sig-name descname"><span class="pre">set_scaled_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_scaled_positions" title="Link to this definition"></a></dt>
<dd><p>Set positions relative to unit cell.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_tags">
<span class="sig-name descname"><span class="pre">set_tags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_tags" title="Link to this definition"></a></dt>
<dd><p>Set tags for all atoms. If only one tag is supplied, it is
applied to all atoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.set_velocities">
<span class="sig-name descname"><span class="pre">set_velocities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">velocities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.set_velocities" title="Link to this definition"></a></dt>
<dd><p>Set the momenta by specifying the velocities.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.symbols">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">symbols</span></span><a class="headerlink" href="#matscipy.opls.OPLSStructure.symbols" title="Link to this definition"></a></dt>
<dd><p>Get chemical symbols as a <code class="xref py py-class docutils literal notranslate"><span class="pre">ase.symbols.Symbols</span></code> object.</p>
<p>The object works like <code class="docutils literal notranslate"><span class="pre">atoms.numbers</span></code> except its values
are strings.  It supports in-place editing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.todict">
<span class="sig-name descname"><span class="pre">todict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.todict" title="Link to this definition"></a></dt>
<dd><p>For basic JSON (non-database) support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">displacement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.translate" title="Link to this definition"></a></dt>
<dd><p>Translate atomic positions.</p>
<p>The displacement argument can be a float an xyz vector or an
nx3 array (where n is the number of atoms).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">wrap_kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.wrap" title="Link to this definition"></a></dt>
<dd><p>Wrap positions to unit cell.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>wrap_kw: (keyword=value) pairs</dt><dd><p>optional keywords <cite>pbc</cite>, <cite>center</cite>, <cite>pretty_translation</cite>, <cite>eps</cite>,
see <code class="xref py py-func docutils literal notranslate"><span class="pre">ase.geometry.wrap_positions()</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.opls.OPLSStructure.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.opls.OPLSStructure.write" title="Link to this definition"></a></dt>
<dd><p>Write atoms object to a file.</p>
<p>see ase.io.write for formats.
kwargs are passed to ase.io.write.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="matscipy.hydrogenate.html" class="btn btn-neutral float-left" title="matscipy.hydrogenate" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="matscipy.angle_distribution.html" class="btn btn-neutral float-right" title="matscipy.angle_distribution" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, James Kermode, Lars Pastewka, et al.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>